<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Young"><meta name="copyright" content="Young"><title>JUTSSAM</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JUTSSAM" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Young</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">JUTSSAM</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">home</a><a class="site-page" href="/archives">archives</a><a class="site-page" href="/tags">tags</a><a class="site-page" href="/search">search</a><a class="site-page" href="/about">about</a><a class="site-page" href="/atom.xml">rss</a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">JUTSSAM</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/06/never-pay-for-the-live/">妈妈再也不用担心我付费看直播了</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-05</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/andriod/">andriod</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>* 本文只用于技术交流，请勿用于非法活动。</p>
<p>涉及的内容包含安卓逆向、安卓内存注入和封包拦截修改。</p>
<h1 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h1><p>最近对移动端的通信比较感兴趣，于是遇到一个陌生的APP习惯性地丢到模拟器上抓包看看。同类APP一般都是明文数据传输，因为是直播APP，它的推流地址容易暴露被其他的人直接利用。让我惊喜的是这个通信数据的data字段是加密的，这引起了我的兴趣。</p>
<p>数据格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"errcode"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"data"</span>:<span class="string">"74BE4E705C1A059BEC92B06E6A47D2E6C5DB796709F500146B34BD4B941A"</span>,</span><br><span class="line">  <span class="attr">"sign"</span>:<span class="string">"c35cf5905b9977d865a022a14e9b74c9"</span>,</span><br><span class="line">  <span class="attr">"timestamp"</span>:<span class="number">1591363269349</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中data部分进行了加密操作，sign一般都是验证数据是否遭到篡改。</p>
<h1 id="找出它的加密算法"><a href="#找出它的加密算法" class="headerlink" title="找出它的加密算法"></a>找出它的加密算法</h1><h2 id="逆向安卓的代码"><a href="#逆向安卓的代码" class="headerlink" title="逆向安卓的代码"></a>逆向安卓的代码</h2><p>想把apk搞成我能看懂的代码，也就是逆向一下，我找到了三个办法：</p>
<ol>
<li>直接解压</li>
<li>使用apktool逆向</li>
<li>用frida抓内存中的数据</li>
</ol>
<p>使用前两个方法都只得到了一个stubApplication的东西：</p>
<p><img src="/images/image-20200605224312331.png" alt="使用jd-gui打开jar文件"></p>
<p>看不到业务逻辑部分的代码，应该是用了一些手段，但是在lib和assets文件夹中都没有找到可能的文件，应该是加了壳，需要脱壳。</p>
<p>观察前两种方法得到的文件，发现并没有用到类似360一些公司提供的加壳方法，而是使用了 “ <a href="https://document.kiwisec.com/product/KiwiVM-so.html" target="_blank" rel="noopener">Android源码虚拟化加密</a> ”，经过一番查找，发现了一个大杀器- <strong>frida</strong>。</p>
<p>虽然不太懂安卓代码加载的逻辑，但是有一个是确定的：代码终究是要加载到内存中运行的。</p>
<p>于是使用工具 <a href="https://github.com/hluwa/FRIDA-DEXDump" target="_blank" rel="noopener">FRIDA-DEXDump</a> ，把apk加载到内存中的dex文件搞到手了。</p>
<p>其中细节不多赘述，可以参考<a href="[https://zhzhdoai.github.io/2020/05/13/Android%E9%80%86%E5%90%91-%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95frida-dump-dex%E5%B9%B6hook/](https://zhzhdoai.github.io/2020/05/13/Android逆向-复现记录frida-dump-dex并hook/)">[Android逆向]复现记录frida dump dex并hook</a>。该文章中提到的内存注入，也是我们后文要提到的破解直播的一种办法。</p>
<h2 id="找到加密算法"><a href="#找到加密算法" class="headerlink" title="找到加密算法"></a>找到加密算法</h2><p>APP用到了比较高级的加壳算法，很担心它把加密算法放在native函数里实现，这样子的话逆向出来比较费劲。但是总要试一试。</p>
<p>使用jeb打开拖出来的dex文件，在其主要实现逻辑的代码中找和请求、响应相关文件中找，因为已经知道它的请求和响应格式，应该会有<strong>响应格式的bean</strong>或者<strong>处理函数中会有map格式对json数据进行处理</strong>。于是发现了一个实现打包请求参数的bean-<strong>HttpParam</strong>。它使用一个linkedlist对数据进行管理，进行请求提交的时候包装成map格式，然后转化成json格式。</p>
<p>而且凑巧的是发现了一个函数中输出日志 :”<strong>加密之後數據為：XXX</strong>“。可以确定加密函数就在它的附近了。</p>
<p>果然在一个类里实现了加密和解密函数，包含对AES的key的加密和data数据的加密解密。没想到快乐来的这么快。加密解密算法使用Java实现而且放在同一个类里。🤣枯燥。</p>
<p>加密解密算法在这里：<a href="https://github.com/JUTSSAM/JEAA" target="_blank" rel="noopener">JEAA</a>。</p>
<h2 id="破解直播"><a href="#破解直播" class="headerlink" title="破解直播"></a>破解直播</h2><p>此时我们已经可以通过解密算法对接口数据进行破解，直播的rtmp推流地址已经可以拿到，但是使用vlc直接播放是解码失败的，只有一团杂色。但是我本机环境没有安卓开发环境，使用ijkplayer测试推流接口比较费劲。</p>
<p>要破解付费直播房间的判断，有两种思路：</p>
<ol>
<li>找到判断函数，注入修改其返回值。</li>
<li>修改响应参数，欺骗本地APP，让其认为该直播间是免费的。</li>
</ol>
<p><a href="[https://zhzhdoai.github.io/2020/05/13/Android%E9%80%86%E5%90%91-%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95frida-dump-dex%E5%B9%B6hook/](https://zhzhdoai.github.io/2020/05/13/Android逆向-复现记录frida-dump-dex并hook/)">[Android逆向]复现记录frida dump dex并hook</a>中提到了注入的方法，使用js代码修改变量内容，即可实现对判断的修改，本文不进行详细描述。</p>
<p>第二种思路，使用charles，在对应的接口设置断点（针对response），APP进行请求时，对返回数据进行解码获得请求内容，然后使用我们的加密函数重新包装，将加密的结果改到charles的response里，就可以完成对APP的欺骗，最后成功在APP中打开付费房间（甚至没有登陆）。</p>
<h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="[https://zhzhdoai.github.io/2020/05/13/Android%E9%80%86%E5%90%91-%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95frida-dump-dex%E5%B9%B6hook/](https://zhzhdoai.github.io/2020/05/13/Android逆向-复现记录frida-dump-dex并hook/)">[Android逆向]复现记录frida dump dex并hook</a></p>
<p><a href="https://xz.aliyun.com/t/7670#toc-0" target="_blank" rel="noopener">使用Frida给apk脱壳并穿透加固Hook函数</a></p>
<p><a href="https://blog.csdn.net/yanhaijunyan/article/details/105297323" target="_blank" rel="noopener">charles修改响应内容</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/11/23/docker-introduction/">Docker 应用导论</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-23</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/docker/">docker</a></span><div class="content"><h2 id="一-安装"><a href="#一-安装" class="headerlink" title="一.安装"></a>一.安装</h2><p>根据官网指引安装即可：<br><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p>
<h2 id="二-概念解释"><a href="#二-概念解释" class="headerlink" title="二.概念解释"></a>二.概念解释</h2><p>镜像（image）&amp; 容器（container）：镜像和容器的关系类似于操作系统中 [程序] 和 [进程] 的关系，镜像中包含应用中所需要的所有文件内容，运行当中的镜像实例，则被称为容器。</p>
<p>服务（service）&amp;  栈（stack）：笔者简单理解为，单机中多容器应用的部署使用的是service工具，在集群当中部署服务时，则需要栈工具。</p>
<p>集群（swarm）：一系列运行docker的主机，使用swarm进行统一的配置和管理。</p>
<p><img src="/images/1653617-fe49fc2393d898ee.png" alt="Base introduction"></p>
<h2 id="三-应用"><a href="#三-应用" class="headerlink" title="三.应用"></a>三.应用</h2><h3 id="部署单机多容器开发环境-以开源项目laradock为例"><a href="#部署单机多容器开发环境-以开源项目laradock为例" class="headerlink" title="部署单机多容器开发环境(以开源项目laradock为例)"></a>部署单机多容器开发环境(以开源项目laradock为例)</h3><ul>
<li>docker-compose</li>
</ul>
<p><em>compose</em>可以用来定义和管理多容器应用，通过配置yaml格式的文件，定义所需要的容器版本以及环境变量。 </p>
<p>通过<em>docker-compose build</em>建立配置中设定的容器。 </p>
<p>docker-compose up和docker-compose down分别管理应用的开启和关闭。  </p>
<ul>
<li>容器的IP地址</li>
</ul>
<p>每次容器启动时，都会获得一个docker内网IP地址，可通过以下命令获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format&#x3D;&#39;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#39; $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<p>容器之间通信即使用此IP地址。  </p>
<p>Laradok是一个全面的PHP单机开发环境，可选择安装单机应用所需要的容器。<br>仅需要三步即可在docker中运行PHP应用。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 git clone https:&#x2F;&#x2F;github.com&#x2F;Laradock&#x2F;laradock.git </span><br><span class="line">2 cp env-example .env </span><br><span class="line">3 docker-compose up -d nginx mysql phpmyadmin redis workspace</span><br></pre></td></tr></table></figure>

<p>通过浏览器 <a href="http://localhost">http://localhost</a> 即可看到页面运行的结果。</p>
<p>laradock默认安装当前最新发行版，对于一些基于老版本开发的项目可能会出现冲突的情况，此时需要修改镜像的版本，重新拉取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 修改laradock&#x2F;.env 中容器版本**_VERSION&#x3D;&#123;需要的版本&#125;</span><br><span class="line">2 运行 docker-compose build --no-cache &#123;image-name&#125;</span><br></pre></td></tr></table></figure>
<p>laradock 将 [laradock文件所在目录] 映射到/var/www/目录中，<br>[容器配置文件]在 laradock/{container-name}/中。</p>
<ul>
<li>多站点配置</li>
</ul>
<p>在一个nginx服务器上部署多个站点</p>
<p>1 在laradock/nginx/sites 中按nginx格式编写新的站点的配置，将目录指向container中的路径<br>如 var/www/hello<br>2 在本机中的laradock同级目录下 或者 在容器中var/www/目录中添加 hello 文件夹，即得到站点根目录</p>
<p>在其中编辑站点，即可根据站点配置域名，进行访问</p>
<h3 id="部署多台服务器负载均衡服务"><a href="#部署多台服务器负载均衡服务" class="headerlink" title="部署多台服务器负载均衡服务"></a>部署多台服务器负载均衡服务</h3><p>在 <em>docker-compose.yml</em> 文件中设置好设备数及要部署的镜像。</p>
<p><em>docker-machine</em>可以用来管理配置和管理多台docker主机(Docker Engine)。在本地操作机器上安装docker-machine工具，即可创建访问docker主机。</p>
<p>创建可以通过docker-machine操作的虚拟机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1</span><br><span class="line">docker-machine create --driver virtualbox myvm2</span><br></pre></td></tr></table></figure>
<p>运行 <em>docker-machine ls</em> 即可看到所创建的虚拟机列表</p>
<p>通过docker-machine访问虚拟机的两种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 docker-machine ssh myvm1 &quot; &#123;bash script&#125; &quot;</span><br><span class="line">bash script可以是在单机docker应用中所用的命令</span><br><span class="line">2 docker-machine env myvm1</span><br></pre></td></tr></table></figure>

<p>运行该命令，即可进入myvm1的运行环境中，共享文件以及进行一系列的操作</p>
<p><em>docker swarm*是官方实现的集群管理工具，<br>使用命令 *docker swarm init</em> 即可初始化一个集群的管理节点；<br>使用命令 <em>docker swarm join –token <token> <vm ip>:<ip></em> 即可加入一个集群，做为其中的一个从节点。<br>如果需要离开当前所在集群，运行 <code>docker swarm leave -force</code> 即可。</p>
<p>对于管理节点，在 <em>docker-compose.yml</em> 所在目录下，运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack  deploy -c docker-compose.yml &#123;stack-name&#125;</span><br></pre></td></tr></table></figure>

<p>即可在集群当中部署我们在yaml文件中所设置的内容<br>其中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls 查看stack列表</span><br><span class="line">docker stack ps &#123;stack-name&#125; 查看stack内container运行情况</span><br><span class="line">docker stop&#x2F;start stack-name 可以选择开启&#x2F;停止</span><br></pre></td></tr></table></figure>

<p>如果swarm各个节点上的http服务运行成功，那么恭喜，站在docker这个巨人的肩膀上，已经成功实现了http服务负载均衡，迈出了云计算的第一步。</p>
<h2 id="四-原理介绍"><a href="#四-原理介绍" class="headerlink" title="四.原理介绍"></a>四.原理介绍</h2><p>docker使用的是典型的<code>C/S</code>架构，由client接受指令，通过与server的通信来指挥容器相关的一系列操作。<br>也就是说可以通过本机内部以C/S架构使用，也可以与外部部署的容器进行连接。</p>
<h3 id="容器发展进程："><a href="#容器发展进程：" class="headerlink" title="容器发展进程："></a>容器发展进程：</h3><p><img src="/images/1653617-1d296724d01b3fe6.png" alt="History of container"></p>
<ul>
<li>chroot(change root directory) </li>
</ul>
<p>更改root目录，在Linux系统中默认的目录结构是<code>/</code>，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 <code>/</code> 位置。</p>
<p>使用chroot之后，系统读到的目录和文件不再是旧系统根下的而是新系统根下的（被指定的新的位置）的目录结构和文件。</p>
<p>作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 增加系统的安全性，限制了用户的权力</span><br><span class="line">新根下访问不到旧的根目录结构和文件，一般在login之前使用chroot，以此实现用户不能访问到特定的文件。</span><br><span class="line">2 建立一个与原系统隔离的系统目录结构，方便用户开发</span><br><span class="line">使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</span><br><span class="line">3 切换系统的根目录位置，引导 Linux 系统启动以及急救系统</span><br><span class="line">切换到一个临时系统</span><br></pre></td></tr></table></figure>

<ul>
<li>FreeBSD jail</li>
</ul>
<p>chroot限制进程只能存取某个部分的文件系统，但是FreeBSD jail机制限制了在jail中运行的进程，不能影响操作系统中的其他部分。运行在一个 [沙盒] 上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟化：每个jail都是在主机上执行的虚拟环境，有自己的档案系统，进程，普通用户和超级用户。在jail中运行的进程和实际的操作系统环境几乎是一样的。</span><br><span class="line">安全性：每个软件监狱都是独立运作，与其他软件监狱隔离，因此能够提供额外的安全层级。</span><br><span class="line">容易删除及创建：因为每个软件监狱的运作范围有限，这使得系统管理者可以在不影响整体系统的前提下，以超级使用者的权限，来删除在软件监狱下运作的行程。</span><br></pre></td></tr></table></figure>

<ul>
<li>LXC(Linux Containers)</li>
</ul>
<p>一种操作系统虚拟化技术，为Linux内核容器提供用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得Linux用户可以容易的创建和管理系统或应用容器。</p>
<ul>
<li>cgroups</li>
</ul>
<p>其名称源自控制组群（control groups）的简写，是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。<br>cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程(像nice)到操作系统层虚拟化(像OpenVZ，Linux-VServer，LXC)。</p>
<p>在Linux内核中，提供了cgroups功能，来达成资源的区隔化。它同时也提供了名称空间区隔化的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括进程树，网络，用户id，以及挂载的文件系统。但是cgroups并不一定需要启动任何虚拟机。</p>
<p>LXC利用cgroups与名称空间的功能，提供应用软件一个独立的操作系统环境。LXC不需要Hypervisor这个软件层，软件容器（Container）本身极为轻量化，提升了创建虚拟机的速度。软件Docker被用来管理LXC的环境。</p>
<ul>
<li>Docker</li>
</ul>
<p>容器化-操作系统级虚拟化，容器们各自为政，可以互相通信，所有的容器用的是同一个操作系统内核。<br>0.9版本以后，不再使用LXC，代替的是go语言开发libcontainer libarary.(2014) </p>
<ul>
<li>runc</li>
</ul>
<p>根据OCI（Open Container Initiative）规范，生成和运行容器的命令行工具。（OCI,由docker和其他容器行业的领导者制定的容器运行时规范，以及镜像规范）。<br>0.9版本以后，docker改用了runc作为容器管理组件。</p>
<ul>
<li>moby</li>
</ul>
<p>把docker-ce及部分开源打包成立新项目moby。docker区分为docker-ee和docker-ce版本，开始商业化运作。<br>其中Linuxkit较有研究价值。</p>
<h3 id="Docker-ce容器部分简单介绍："><a href="#Docker-ce容器部分简单介绍：" class="headerlink" title="Docker-ce容器部分简单介绍："></a>Docker-ce容器部分简单介绍：</h3><p><img src="/images/1653617-7fe3b81c23baec9c.png" alt="stucture of engine"></p>
<h4 id="containerd的架构"><a href="#containerd的架构" class="headerlink" title="containerd的架构"></a>containerd的架构</h4><p>containerd is an industry-standard container runtime with an emphasis on simplicity, robustness and portability. It is available as a daemon for Linux and Windows, which can manage the complete container lifecycle of its host system: image transfer and storage, container execution and supervision, low-level storage and network attachments, etc.</p>
<p>容器运行时管理工具，包含daemon，image transfer and storage，容器执行和监听，网络连接等等。</p>
<p><img src="/images/1653617-c1d0d451d5a15302.png" alt="structure of containerd"></p>
<p>以下代码使用了containerd所实现的client借口，给出了一系列参数可以对容器进行操作。代码中所演示的是 [拉取redis镜像] 的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;context&quot;</span><br><span class="line">   &quot;log&quot;</span><br><span class="line"></span><br><span class="line">   &quot;github.com&#x2F;containerd&#x2F;containerd&quot;</span><br><span class="line">   &quot;github.com&#x2F;containerd&#x2F;containerd&#x2F;namespaces&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   if err :&#x3D; redisExample(); err !&#x3D; nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func redisExample() error &#123;</span><br><span class="line">   client, err :&#x3D; containerd.New(&quot;&#x2F;run&#x2F;containerd&#x2F;containerd.sock&quot;)</span><br><span class="line">   if err !&#x3D; nil &#123;</span><br><span class="line">      return err</span><br><span class="line">   &#125;</span><br><span class="line">   defer client.Close()</span><br><span class="line"></span><br><span class="line">   ctx :&#x3D; namespaces.WithNamespace(context.Background(), &quot;example&quot;)</span><br><span class="line">   image, err :&#x3D; client.Pull(ctx, &quot;docker.io&#x2F;library&#x2F;redis:alpine&quot;, containerd.WithPullUnpack)</span><br><span class="line">   if err !&#x3D; nil &#123;</span><br><span class="line">      return err</span><br><span class="line">   &#125;</span><br><span class="line">   log.Printf(&quot;Successfully pulled %s image\n&quot;, image.Name())</span><br><span class="line"></span><br><span class="line">   return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码运行结果</p>
<p><img src="/images/1653617-fc98ea53383ac6a8.png" alt="result"></p>
<p>在示例代码中，创建了和container daemon的连接，然后设置系统用户命名空间，在其中从docker.io pull了一个redis镜像到本地。</p>
<p>利用containerd，我们可以定制开发自己的容器管理工具，符合OCI规范，可以使用如docker的image等其他镜像。</p>
<h4 id="图形化操作界面-portainer："><a href="#图形化操作界面-portainer：" class="headerlink" title="图形化操作界面-portainer："></a>图形化操作界面-portainer：</h4><p>一个轻量级的图形化docker管理工具。<br>示例网站：<a href="http://demo.portainer.io/" target="_blank" rel="noopener">http://demo.portainer.io/</a> ，依赖于docker开源项目client功能开发。</p>
<h2 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE:"></a>REFERENCE:</h2><p><a href="http://docker.io/" target="_blank" rel="noopener">Docker doc - get started</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/index.html" target="_blank" rel="noopener">理解chroot</a></p>
<p><a href="https://github.com/opencontainers" target="_blank" rel="noopener">github/containers</a></p>
<p><a href="https://github.com/seccomp/libseccomp" target="_blank" rel="noopener">github/seccomp</a></p>
<p><a href="https://www.opencontainers.org/" target="_blank" rel="noopener">opencontainer</a></p>
<p><a href="https://github.com/portainer/portainer" target="_blank" rel="noopener">github/portrainer</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/07/01/php-vitual-machine/">[译] PHP虚拟机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/PHP/">PHP</a></span><div class="content"><hr>
<p>本篇文章旨在提供一个对PHP7版本中Zend虚拟机的概述，不会做到面面俱到的详细叙述，但尽力包含大多数重要的部分，以及更精细的细节。</p>
<p>这篇文章描述的主要背景是PHP版本7.2（当前正在开发版本），但几乎同样适用于PHP7.0/7.1版本中。然而，PHP5.x系列版本的虚拟机之间差别比较显著，笔者不会去比较。</p>
<p>本文的大部分内容将在指令列表级别进行考虑，最后只有几节讨论VM的实际C语言实现。但是，我确实想提供一些组成VM前端的主要文件：</p>
<ul>
<li>zend_vm_def.h：VM定义文件</li>
<li>zend_vm_execute.h：<code>生成的虚拟机文件</code></li>
<li>zend_vm_gen.php：生成脚本</li>
<li>zend_execute.c：大多数直接支持文件</li>
</ul>
<h2 id="操作码-（Opcodes）"><a href="#操作码-（Opcodes）" class="headerlink" title="操作码 （Opcodes）"></a>操作码 （Opcodes）</h2><p>首先我们来谈一下操作码，“操作码”是指完整的VM指令(包括操作数)，但也可以只指定“实际”操作代码–一个决定指令类型的小整数。从上下文来看，指令的意图应该是清晰的。在文件源码中，完整的指令通常被称为Opline。</p>
<p>一个独立的指令遵循如下zend_op结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_op &#123;</span><br><span class="line">    const void *handler;</span><br><span class="line">    znode_op op1;</span><br><span class="line">    znode_op op2;</span><br><span class="line">    znode_op result;</span><br><span class="line">    uint32_t extended_value;</span><br><span class="line">    uint32_t lineno;</span><br><span class="line">    zend_uchar opcode;</span><br><span class="line">    zend_uchar op1_type;</span><br><span class="line">    zend_uchar op2_type;</span><br><span class="line">    zend_uchar result_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，操作码实质上是“三地址”指令格式。其中‘opcode’决定指令类型，还有两个输入的操作数‘op1’和‘op2’以及一个输出操作数‘result’。</p>
<p>并不是所有的指令都会用到所有的操作数。ADD指令（代表+操作符）会用到三个操作数。BOOL_NOT指令（代表！操作符）只用到op1和result。ECHO指令只会用到op1操作符。有些指令甚至可以使用或者不使用操作符。例如，DO_FCALL可以使用或者不使用result操作符，具体取决于是否使用函数调用的返回值。有些指令需要两个以上输入操作数，在这种情况下，只需要使用<del>第二个</del>虚拟指令/伪指令（OP_DATA）来携带额外的操作数。</p>
<p>除了这三个标准操作数之外，还有一个附加的数值extended_value 字段，可以用来保存附加的指令修饰符。例如，对于强制转换（CAST），它可能包含要强制转换的目标类型。</p>
<p>每个操作数都有对应的一个类型，分别存储在op1_type, op2_type和result_type中。可能的类型有IS_UNUSED, IS_CONST, IS_TMPVAR, IS_VAR and IS_CV。</p>
<p>后三种类型指定变量操作数(有三种不同类型的VM变量)，IS_CONST表示常量操作数(5或“String”或偶数[1，2，3])，而IS_UNUSED表示实际未使用的操作数，或作为32位数值(汇编术语中的“立即”)使用的操作数。例如，跳转指令将跳转目标存储在未使用的操作数中。</p>
<h2 id="获取操作指令（Obtaining-opcode-dumps"><a href="#获取操作指令（Obtaining-opcode-dumps" class="headerlink" title="获取操作指令（Obtaining opcode dumps)"></a>获取操作指令（Obtaining opcode dumps)</h2><p>接下来，笔者将经常列出PHP代码生成的操作码序列。目前有三种方法可以将这些操作码转储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Opcache, since PHP 7.1</span><br><span class="line">php -d opcache.opt_debug_level&#x3D;0x10000 test.php</span><br><span class="line"></span><br><span class="line"># phpdbg, since PHP 5.6</span><br><span class="line">phpdbg -p* test.php</span><br><span class="line"></span><br><span class="line"># vld, third-party extension</span><br><span class="line">php -d vld.active&#x3D;1 test.php</span><br></pre></td></tr></table></figure>

<p>其中，Opcache提供了最高质量的输出。本文中使用的清单基于opcache转储，并进行了一些语法调整。魔术数字0x10000是“优化前”的缩写，因此我们看到PHP编译器生成的操作码。0x20000会给你优化的操作码。Opcache还可以生成更多的信息，例如0x40000将生成一个<code>CFG</code>，而0x200000将生成<code>类型和范围推断的SSA表单</code>。但这已经超越了我们想要的：普通的、原本的线性化操作码转储对我们来说就足够了。</p>
<h2 id="变量类型（Variable-types）"><a href="#变量类型（Variable-types）" class="headerlink" title="变量类型（Variable types）"></a>变量类型（Variable types）</h2><p>在研究虚拟机时，可能需要理解的最重要的一点在于它使用的三种不同的变量类型：<br>CV是“compiled variable”的缩写，而且指向一个“真正的”PHP变量。如果函数使用变量$a，就会有$a对应的CV。</p>
<p>CV可以有UNDEF类型，用来指向未定义变量。如果UNDEF CV在一个指令中用到，在大多数情况下会抛出“未定义变量（undefined variable）”提示。在函数入口处所有非参数CV会被初始化为UNDEF。</p>
<p>CV不会被指令<code>消耗</code>(consumed)，例如，指令ADD $a,$b 不会销毁存储在CV中的变量$a和$b。然而所有的CV都会在<code>事务(scope)</code>退出时一起销毁。这也暗示所有的CV在整个函数的域内都将‘live’–包含一个有效值。</p>
<p>TMPVARS和VARS是虚拟机的临时变量。它们通常被用作一些操作指令的结果操作数。例如$a = $b + $c + $d会输出如下类似指令序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T0 &#x3D; ADD $b,$c</span><br><span class="line">T1 &#x3D; ADD T0,$d</span><br><span class="line">ASSIGN $a,T1</span><br></pre></td></tr></table></figure>
<p>TMP/VAR是在使用前定义的，因此不能保存UNDEF值。与CV不同，这些变量类型是由它们所使用的指令所消耗的。在上面的示例中，第二个ADD将破坏T0操作数的值，在此之后不能使用T0(除非事先写入)。类似地，ASSIGN将消耗T1的值，使T1无效。</p>
<p>因此，TMP/VAR通常寿命很短。在许多情况下，一个临时变量只存在一个指令的空间。在这个短暂的活动之外，临时变量就成了垃圾。</p>
<p>那么TMP和VAR有什么区别呢？不多。这种区别是从PHP5继承的，TMP是分配在VM栈中的，而VAR是分配在堆中的。在PHP7中，所有变量都是分配在栈中。因此，现在TMP和VAR的主要区别是只允许后者包含引用(REFERENCEs)(这允许我们在TMP上删除DEREF)。此外，VAR可能包含两种特殊值，即<code>类条目</code>(class entries)和间接值(INDIRECT values)。后者用于处理特殊的任务。</p>
<p>下方图表分析了主要的区别：<br>|-     |UNDEF|REF |INDIRECT|Consumed?|Named?|<br>|—   |—  |—-|—-    |—-     |—-  |<br>|CV    |yes  |yes |no      |no       |yes   |<br>|TMPVAR|no   |no  |no      |yes      |no    |<br>|VAR   |  no | yes|   yes  |yes      | no   |</p>
<h2 id="指令数组（Op-arrays）"><a href="#指令数组（Op-arrays）" class="headerlink" title="指令数组（Op arrays）"></a>指令数组（Op arrays）</h2><p>所有PHP函数都表示为具有公共Zend_Function的 Header结构。这里的“函数”应该有一些广义的理解，包括从“真正的”函数到方法，到独立的“伪主(pseudo-main)”代码和“eval”代码。</p>
<p>用户级函数使用zend_op_Array结构。它有30多个成员，所以我现在先从一个简化版本开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_op_array &#123;</span><br><span class="line">    &#x2F;* Common zend_function header here *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">    uint32_t last;</span><br><span class="line">    zend_op *opcodes;</span><br><span class="line">    int last_var;</span><br><span class="line">    uint32_t T;</span><br><span class="line">    zend_string **vars;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">    int last_literal;</span><br><span class="line">    zval *literals;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最重要的部分当然是opcodes，它是一个包含操作指令的数组。‘last’是数组中操作指令的数量，注意这里的术语可能令人感到困惑，‘last’看起来像是最后一个操作指令的索引，但是这里实际上是操作数的数量（比最后一个操作数的索引大一）。这同样适用于op数组结构中的所有其他‘last_ *’值。</p>
<p>‘last_var’是CV的数量，‘T’是TMP和VAR的数量（在大多数情况下两者没有明显的区别）。‘vars’是CV的命名。<br>‘literals’是出现在代码中字面值的数组，这个数组是CONST操作数引用。根据<strong>ABI①</strong>，每个CONST操作数要么储存指向次文本表的引用，要么存储相对于其开始的偏移量。</p>
<p>关于op数组（op array）的内容不止于此。</p>
<h2 id="栈框架布局（Stack-frame-layout）"><a href="#栈框架布局（Stack-frame-layout）" class="headerlink" title="栈框架布局（Stack frame layout）"></a>栈框架布局（Stack frame layout）</h2><p>除了一些全局指令EG(excutor globals)，所有的执行状态都存储在虚拟机栈中。虚拟机栈以大小为256KB的page分配，通过链表进行连接。</p>
<p>每一个函数调用时，将在VM栈上分配一个新的栈帧，布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------+</span><br><span class="line">| zend_execute_data                      |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| VAR[0]                &#x3D;         ARG[1] | arguments</span><br><span class="line">| ...                                    |</span><br><span class="line">| VAR[num_args-1]       &#x3D;         ARG[N] |</span><br><span class="line">| VAR[num_args]         &#x3D;   CV[num_args] | remaining CVs</span><br><span class="line">| ...                                    |</span><br><span class="line">| VAR[last_var-1]       &#x3D; CV[last_var-1] |</span><br><span class="line">| VAR[last_var]         &#x3D;         TMP[0] | TMP&#x2F;VARs</span><br><span class="line">| ...                                    |</span><br><span class="line">| VAR[last_var+T-1]     &#x3D;         TMP[T] |</span><br><span class="line">| ARG[N+1] (extra_args)                  | extra arguments</span><br><span class="line">| ...                                    |</span><br><span class="line">+----------------------------------------+</span><br></pre></td></tr></table></figure>
<p>该框架以一个zend_execute_data结构开始，接着是一个变量槽（variable slots）的数组。这些变量槽都相同（simple zvals），但是用作不同的用途。第一个‘last_var’槽中内容是CV，其中第一个num_args存放函数参数。CV插槽之后是TMP/ VAR的‘T’插槽。最后，有时可以在帧的末尾存储“额外”参数。这些用于处理func_get_args()。</p>
<p>指令中的CV和TMP/VAR操作数被编码为相对于堆栈起始位置的偏移量，因此读取某个变量只是从execute_data位置读取的偏移量。</p>
<p>帧开始处的执行数据定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> zend_op       *opline;</span><br><span class="line">    zend_execute_data   *call;</span><br><span class="line">    zval                *return_value;</span><br><span class="line">    zend_function       *func;</span><br><span class="line">    zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">    zend_class_entry    *called_scope;</span><br><span class="line">    zend_execute_data   *prev_execute_data;</span><br><span class="line">    zend_array          *symbol_table;</span><br><span class="line">    <span class="keyword">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">    zval                *literals;         <span class="comment">/* cache op_array-&gt;literals       */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最重要的是，这个结构包含opline（当前执行的指令）和func（它是当前执行的函数）。此外：</p>
<ul>
<li>return_value是一个指向将存储返回值的zval的指针。</li>
<li>‘This’是$this对象，但也会编码一些未使用的zval空间中函数参数的数目和一些调用元数据标志。</li>
<li>called_scope是static ::在PHP代码中引用的范围。</li>
<li>prev_execute_data指向前一个栈帧，在此函数完成运行后，执行将返回到该帧。</li>
<li>symbol_table是一个通常未使用的符号表，用于某些疯狂的人实际使用变量变量或类似功能的情况。（$$a）</li>
<li>run_time_cache缓存op数组运行时缓存，以便在访问此结构时避免一个指针间接寻址（稍后讨论）。</li>
<li>由于相同的原因，literals缓存op数组字面量表。</li>
</ul>
<h2 id="函数调用（Function-calls）"><a href="#函数调用（Function-calls）" class="headerlink" title="函数调用（Function calls）"></a>函数调用（Function calls）</h2><p>笔者跳过了execute_data结构中的一个字段–‘call’，因为它需要关于函数调用如何工作的更多上下文。所有调用都使用相同指令序列的变体。全局作用域中的var_dump（$a，$b）将编译为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INIT_FCALL (2 args) &quot;var_dump&quot;</span><br><span class="line">SEND_VAR $a</span><br><span class="line">SEND_VAR $b</span><br><span class="line">V0 &#x3D; DO_ICALL   # or just DO_ICALL if retval unused</span><br></pre></td></tr></table></figure>
<p>有八种不同类型的INIT指令，取决于它是什么类型的调用。INIT_FCALL与调用相关，用来释放我们在编译时识别的函数。同样，根据参数和函数的类型，有十个不同的SEND操作码。只有数量较少的四个DO_CALL操作码，其中ICALL用于调用内部函数。</p>
<p>虽然具体指令可能不同，但结构总是相同的：INIT，SEND，DO。调用序列必须解决的主要问题是嵌套函数调用，它们编译如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># var_dump(foo($a), bar($b))</span><br><span class="line">INIT_FCALL (2 args) &quot;var_dump&quot;</span><br><span class="line">    INIT_FCALL (1 arg) &quot;foo&quot;</span><br><span class="line">    SEND_VAR $a</span><br><span class="line">    V0 &#x3D; DO_UCALL</span><br><span class="line">SEND_VAR V0</span><br><span class="line">    INIT_FCALL (1 arg) &quot;bar&quot;</span><br><span class="line">    SEND_VAR $b</span><br><span class="line">    V1 &#x3D; DO_UCALL</span><br><span class="line">SEND_VAR V1</span><br><span class="line">V2 &#x3D; DO_ICALL</span><br></pre></td></tr></table></figure>
<p>INIT操作码在堆栈上压入一个调用帧，该帧包含了函数中所有变量的足够空间以及我们所知道的参数的数量（如果涉及参数解包，我们可能会以更多参数结束）。</p>
<p>指向新帧的指针存储到execute_data-&gt; call中，其中execute_data是调用函数的帧。在下面，我们将把这些访问表示为EX（call）。值得注意的是，新帧的prev_execute_data被设置为旧的EX（call）值。例如，调用foo的INIT_FCALL会将prev_execute_data设置为va_dump的堆栈帧（而不是周边函数的栈帧）。因此，在这种情况下，prev_execute_data形成一个“未完成”调用的链表，而通常它会提供回溯链(双向链表)。</p>
<p>SEND操作码然后继续将参数推送到EX（call）的变量槽中。在这一点上，参数都是连续的，并且可以从为参数指定的部分溢出到其他CV或TMP中。这将在稍后修复。</p>
<p>最后DO_FCALL执行实际的调用。EX（call）成为当前函数，prev_execute_data被重新链接到调用函数。除此之外，调用过程取决于它是什么类型的功能。内部函数只需要调用处理函数，而用户级函数需要完成栈帧的初始化。</p>
<p>这个初始化涉及修复参数栈。PHP允许传递比函数期望更多的参数（func_get_args依赖于这个功能）。但是，只有实际声明的参数才具有相应的CV。除此以外的任何参数都会写入为其他CV和TMP保留的内存。因此，这些参数将在TMP之后移动，最终将参数分成两个不连续的块。</p>
<p>为了清楚地说明，用户级函数调用不涉及虚拟机级别的递归。它们只涉及从一个execute_data切换到另一个execute_data，但虚拟机继续以线性循环运行。递归虚拟机调用仅在内部函数调用用户空间回调（例如通过array_map）时才会发生。这就是为什么PHP中的无限递归通常会导致内存限制或OOM错误的原因，通过递归使用回调函数或魔术方法可能引发栈溢出。</p>
<h2 id="参数传递（Argument-sending）"><a href="#参数传递（Argument-sending）" class="headerlink" title="参数传递（Argument sending）"></a>参数传递（Argument sending）</h2><p>PHP使用大量不同的参数发送操作码，这些操作码的区别可能会造成混淆。<br>SEND_VAL和SEND_VAR是最简单的变体，它处理在编译时已知是按值传递时进行的按值传递参数。SEND_VAL用于CONST和TMP操作数，而SEND_VAR用于VAR和CV。</p>
<p>相反，SEND_REF用于在编译期间已知为引用传递的参数传递。由于只有变量可以通过引用发送，这个操作码只接受VAR和CV。</p>
<p>SEND_VAL_EX和SEND_VAR_EX是SEND_VAL / SEND_VAR的变体，用于无法静态确定参数是按值还是按引用传递的情况。这些操作码将根据arginfo检查参数的种类并相应地执行操作。在大多数情况下，不使用实际的arginfo结构，而是直接在函数结构中使用紧凑的位向量表示。</p>
<p>然后是SEND_VAR_NO_REF_EX。不要试图名称上了解这个指令。这个操作码用于传递一些不是真正的“变量”，但是会返回一个VAR到一个静态未知参数的东西。使用它的两个特定示例是将函数调用的结果作为参数传递，或者传递赋值的结果。<strong>②</strong></p>
<p>这种情况需要一个独立的操作码，原因有两个：首先，如果尝试通过ref传递类似于赋值的内容它会生成熟悉的“只能通过引用传递变量”通知（如果使用SEND_VAR_EX，则会被默许）。其次，这个操作码处理的情况是，你可能想要将引用返回函数的结果传递给一个引用参数（它不应该抛出任何东西）。该操作码的SEND_VAR_NO_REF变体（不带_EX）是一种特殊的变体，用于静态地知道引用是预期的情况（但我们不知道该变量是否为一个）。</p>
<p>SEND_UNPACK和SEND_ARRAY操作码分别处理参数解包和内联call_user_func_array调用。它们都将数组中的元素推入参数栈，并在各种细节上有所不同（例如，解包支持Traversables，而call_user_func_array则不支持）。如果使用unpacking/cufa，则可能需要将栈框架扩展超出其以前的大小（因为函数参数的实数在初始化时是未知的）。在大多数情况下，只需移动堆栈顶部指针就可以进行扩展。但是，如果这会跨越堆栈页面边界，则必须分配新页面，并且需要将整个调用帧（包括已经推入的参数）复制到新页面（我们无法处理穿过页面的调用帧边界）。</p>
<p>最后一个操作码是SEND_USER，用于内联调用call_user_func并处理它的一些特性。</p>
<p>虽然我们尚未讨论不同的变量获取模式，但这似乎是介绍FUNC_ARG获取模式的好地方。考虑一个简单的调用func($a[0][1][2])，在编译时我们不知道这个参数是通过值还是通过引用传递的。在这两种情况下，行为将会大不相同。如果传递是按值并且$a以前是空的，则可能必须生成一堆“未定义索引”通知。如果传递是通过引用的话，我们必须默默地初始化嵌套数组。</p>
<p>FUNC_ARG获取模式将通过检查当前EX(call)函数的arginfo来动态选择两种行为之一（R或W）。对于func($a[0][1][2])的例子，操作码序列可能是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INIT_FCALL_BY_NAME &quot;func&quot;</span><br><span class="line">V0 &#x3D; FETCH_DIM_FUNC_ARG (arg 1) $a, 0</span><br><span class="line">V1 &#x3D; FETCH_DIM_FUNC_ARG (arg 1) V0, 1</span><br><span class="line">V2 &#x3D; FETCH_DIM_FUNC_ARG (arg 1) V1, 2</span><br><span class="line">SEND_VAR_EX V2</span><br><span class="line">DO_FCALL</span><br></pre></td></tr></table></figure>

<h2 id="取参模式（Fetch-modes）"><a href="#取参模式（Fetch-modes）" class="headerlink" title="取参模式（Fetch modes）"></a>取参模式（Fetch modes）</h2><p>PHP虚拟机有四类提取操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FETCH_*             &#x2F;&#x2F; $_GET, $$var</span><br><span class="line">FETCH_DIM_*         &#x2F;&#x2F; $arr[0]</span><br><span class="line">FETCH_OBJ_*         &#x2F;&#x2F; $obj-&gt;prop</span><br><span class="line">FETCH_STATIC_PROP_* &#x2F;&#x2F; A::$prop</span><br></pre></td></tr></table></figure>
<p>这些完全符合人们期望它们做的事情，但要注意基本的FETCH_*变体仅用于访问变量变量和超全局变量：正常变量访问通过更快的CV机制来代替。</p>
<p>这些提取操作码每个都有六种变体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_R</span><br><span class="line">_RW</span><br><span class="line">_W</span><br><span class="line">_IS</span><br><span class="line">_UNSET</span><br><span class="line">_FUNC_ARG</span><br></pre></td></tr></table></figure>
<p>我们已经知道，_FUNC_ARG根据函数参数是按值还是按引用来选择_R和_W。让我们尝试创建一些我们期望不同的获取类型出现的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $arr[0];</span><br><span class="line">V2 &#x3D; FETCH_DIM_R $arr int(0)</span><br><span class="line">FREE V2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $arr[0] &#x3D; $val;</span><br><span class="line">ASSIGN_DIM $arr int(0)</span><br><span class="line">OP_DATA $val</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $arr[0] +&#x3D; 1;</span><br><span class="line">ASSIGN_ADD (dim) $arr int(0)</span><br><span class="line">OP_DATA int(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; isset($arr[0]);</span><br><span class="line">T5 &#x3D; ISSET_ISEMPTY_DIM_OBJ (isset) $arr int(0)</span><br><span class="line">FREE T5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; unset($arr[0]);</span><br><span class="line">UNSET_DIM $arr int(0)</span><br></pre></td></tr></table></figure>
<p>不幸的是，这个产生的唯一真正的提取是FETCH_DIM_R：其他的东西都是通过特殊的操作码处理的。请注意，ASSIGN_DIM和ASSIGN_ADD都使用额外的OP_DATA，因为它们需要两个以上的输入操作数。使用特殊操作码（如ASSIGN_DIM）而不是像FETCH_DIM_W + ASSIGN之类的原因是（除了性能），这些操作可能被重载，例如，在ASSIGN_DIM情况下，通过实现ArrayAccess::offsetSet()的对象实现。要实际生成不同的提取类型，我们需要增加嵌套的级别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; $arr[0][1];</span><br><span class="line">V2 &#x3D; FETCH_DIM_R $arr int(0)</span><br><span class="line">V3 &#x3D; FETCH_DIM_R V2 int(1)</span><br><span class="line">FREE V3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $arr[0][1] &#x3D; $val;</span><br><span class="line">V4 &#x3D; FETCH_DIM_W $arr int(0)</span><br><span class="line">ASSIGN_DIM V4 int(1)</span><br><span class="line">OP_DATA $val</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; $arr[0][1] +&#x3D; 1;</span><br><span class="line">V6 &#x3D; FETCH_DIM_RW $arr int(0)</span><br><span class="line">ASSIGN_ADD (dim) V6 int(1)</span><br><span class="line">OP_DATA int(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; isset($arr[0][1]);</span><br><span class="line">V8 &#x3D; FETCH_DIM_IS $arr int(0)</span><br><span class="line">T9 &#x3D; ISSET_ISEMPTY_DIM_OBJ (isset) V8 int(1)</span><br><span class="line">FREE T9</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; unset($arr[0][1]);</span><br><span class="line">V10 &#x3D; FETCH_DIM_UNSET $arr int(0)</span><br><span class="line">UNSET_DIM V10 int(1)</span><br></pre></td></tr></table></figure>
<p>在这里我们看到，尽管最外层的访问使用专用的操作码，嵌套的索引将使用具有适当获取模式的FETCH进行处理。fetch模式的基本区别在于a）如果索引不存在，它们是否生成“未定义偏移量”通知，以及它们是否获取写入值：</p>
<table>
<thead>
<tr>
<th></th>
<th>Notice?</th>
<th>Write?</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>W</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>RW</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>IS</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>UNSET</td>
<td>no</td>
<td>yes-ish</td>
</tr>
</tbody></table>
<p>UNSET的情况有点奇怪，因为它只能读取现有的偏移量以便写入，并且保留单独的未定义的偏移量。正常的写取操作会初始化未定义的偏移量。</p>
<h2 id="写和内存安全（Writes-and-memory-safety）"><a href="#写和内存安全（Writes-and-memory-safety）" class="headerlink" title="写和内存安全（Writes and memory safety）"></a>写和内存安全（Writes and memory safety）</h2><p>Write获取可能包含正常zval或指向另一个zval的INDIRECT指针的返回VAR。当然，在前一种情况下，应用于zval的任何更改都将不可见，因为该值只能通过虚拟机暂时访问。虽然PHP禁止表达[][0] = 42，但我们仍然需要处理这种情况 call()[0] = 42。取决于是call()按值还是按引用返回，此表达式可能会或可能不会有显著效果。</p>
<p>更典型的情况是当提取返回一个INDIRECT时，它包含一个指向正在被修改的存储位置的指针，例如哈希表数据数组中的某个位置。不幸的是，这样的指针是脆弱的东西，容易失效：任何并发写入数组可能会触发重新分配，留下一个悬挂指针。因此，防止在创建INDIRECT值的位置与消耗的位置之间执行用户代码至关重要。</p>
<p>考虑这个例子：<br><code>$arr[a()][b()] = c();</code><br>其中产生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INIT_FCALL_BY_NAME (0 args) &quot;a&quot;</span><br><span class="line">V1 &#x3D; DO_FCALL_BY_NAME</span><br><span class="line">INIT_FCALL_BY_NAME (0 args) &quot;b&quot;</span><br><span class="line">V3 &#x3D; DO_FCALL_BY_NAME</span><br><span class="line">INIT_FCALL_BY_NAME (0 args) &quot;c&quot;</span><br><span class="line">V5 &#x3D; DO_FCALL_BY_NAME</span><br><span class="line">V2 &#x3D; FETCH_DIM_W $arr V1</span><br><span class="line">ASSIGN_DIM V2 V3</span><br><span class="line">OP_DATA V5</span><br></pre></td></tr></table></figure>

<p>值得注意的是，这个序列首先执行从左到右的所有内嵌函数，然后才执行任何必要的写入读取（我们在此将FETCH_DIM_W称为“延迟opline”）。这确保了写访存和<code>消费指令</code>直接相邻。</p>
<p>考虑另一个例子：</p>
<p><code>$arr[0] =&amp; $arr[1];</code></p>
<p>这里我们遇到了一些问题：两边的复制必须提取值才能写入。但是，如果我们抓取$arr[0] 写入然后写入$arr[1]，后者可能会使前者无效。这个问题解决如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V2 &#x3D; FETCH_DIM_W $arr 1</span><br><span class="line">V3 &#x3D; MAKE_REF V2</span><br><span class="line">V1 &#x3D; FETCH_DIM_W $arr 0</span><br><span class="line">ASSIGN_REF V1 V3</span><br></pre></td></tr></table></figure>

<p>这里$arr[1]先取得写入，然后转换成使用MAKE_REF的引用。MAKE_REF的结果不再是间接的并且不会失效，因为这样的获取$arr[0]可以安全地执行。</p>
<h2 id="异常处理（Exception-handling）"><a href="#异常处理（Exception-handling）" class="headerlink" title="异常处理（Exception handling）"></a>异常处理（Exception handling）</h2><p>异常是万恶之源。</p>
<p><del>异常是通过将异常写入EG(异常)来生成的，其中EG指的是执行者全局(Executor Globals)。C代码中抛出异常不涉及堆栈展开，相反，<code>执行退出</code>（abortion）将通过返回值失败代码或检查EG(异常)向上传播。只有当控制器重新进入虚拟机代码时，才会实际处理异常。</del></p>
<p>在某些情况下，几乎所有的VM指令都可能直接或间接导致异常。例如，如果使用自定义错误处理程序，则任何“未定义的变量”通知都可能导致异常。我们希望避免检查EG(exception)每个VM指令后设置。相反，使用一个小窍门：</p>
<p>当抛出一个异常时，当前执行数据的当前选择行被替换为虚拟HANDLE_EXCEPTION opline（这显然不会修改op数组，它只是重定向一个指针）。备份发生异常的对象EG(opline_before_exception)。</p>
<p>这意味着当控制返回到主虚拟机调度循环时，将调用HANDLE_EXCEPTION操作码。这个方案存在一个小问题：它要求 a)存储在执行数据中的opline实际上是当前执行的opline（否则opline_before_exception将会是错误的）并且 b)虚拟机使用来自执行数据的opline来继续执行（否则HANDLE_EXCEPTION不会被调用）。</p>
<p>虽然这些要求可能听起来微不足道，但它们不是。原因是虚拟机可能正在处理与执行数据中存储的opline不同步opline变量。在PHP 7之前，这只发生在很少使用的GOTO和SWITCH虚拟机中，而在PHP 7中，这实际上是默认的操作模式：如果编译器支持它，则opline存储在全局寄存器中。</p>
<p>因此，在执行任何可能会抛出的操作之前，必须将本地对齐线写回执行数据（SAVE_OPLINE操作）。同样，在任何可能的抛出操作之后，必须从执行数据填充本地对象（主要是CHECK_EXCEPTION操作）。</p>
<p>现在，这个机制是在引发异常之后导致HANDLE_EXCEPTION操作码执行的原因。但它有什么作用？首先，它确定是否在try块内引发异常。为此，op数组包含一个try_catch_elements数组，用于跟踪try，catch和finally块的opline偏移量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_try_catch_element &#123;</span><br><span class="line">	uint32_t try_op;</span><br><span class="line">	uint32_t catch_op;  &#x2F;* ketchup! *&#x2F;</span><br><span class="line">	uint32_t finally_op;</span><br><span class="line">	uint32_t finally_end;</span><br><span class="line">&#125; zend_try_catch_element;</span><br></pre></td></tr></table></figure>

<p>现在我们会假装最后的块不存在，因为它们是一个完全不同的。假设我们确实在try块内，VM需要清理在抛出opline之前开始的所有未完成的操作，并且不会跨越try块的末尾。</p>
<p>这涉及释放当前在使用中的所有调用的栈帧和相关数据，以及释放临时变量。在大多数情况下，临时变量存在时间很短，甚至达到消费指令直接跟随着生成指令。然而，它可能发生在跨越多个指令的现场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># (array)[] + throwing()</span><br><span class="line">L0:   T0 &#x3D; CAST (array) []</span><br><span class="line">L1:   INIT_FCALL (0 args) &quot;throwing&quot;</span><br><span class="line">L2:   V1 &#x3D; DO_FCALL</span><br><span class="line">L3:   T2 &#x3D; ADD T0, V1</span><br></pre></td></tr></table></figure>

<p>在这种情况下，T0变量在指令L1和L2中是活动的，因此如果函数调用抛出时需要销毁T0变量。一种特定的临时类型往往具有特别长的活动范围：循环变量。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># foreach ($array as $value) throw $ex;</span><br><span class="line">L0:   V0 &#x3D; FE_RESET_R $array, -&gt;L4</span><br><span class="line">L1:   FE_FETCH_R V0, $value, -&gt;L4</span><br><span class="line">L2:   THROW $ex</span><br><span class="line">L3:   JMP -&gt;L1</span><br><span class="line">L4:   FE_FREE V0</span><br></pre></td></tr></table></figure>

<p>这里“循环变量”V0从L1到L3（通常总是跨越整个循环体）。实时范围使用以下结构存储在操作数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_live_range &#123;</span><br><span class="line">    uint32_t var; &#x2F;* low bits are used for variable type (ZEND_LIVE_* macros) *&#x2F;</span><br><span class="line">    uint32_t start;</span><br><span class="line">    uint32_t end;</span><br><span class="line">&#125; zend_live_range;</span><br></pre></td></tr></table></figure>

<p>这里var是范围适用的（操作数编码的）变量，start是开始选择线偏移量（不包括生成指令），而end如果结束选择线偏移量（包括消耗指令）。当然，如果暂时没有立即消耗，则仅存储活动范围。</p>
<p>低位var用于存储变量的类型，可以是以下之一：</p>
<ul>
<li>ZEND_LIVE_TMPVAR：这是一个“正常”变量。它拥有一个普通的zval值。释放这个变量的行为就像一个免费的操作码。</li>
<li>ZEND_LIVE_LOOP：这是一个foreach循环变量，它不仅包含简单的zval。这对应于FE_FREE操作码。</li>
<li>ZEND_LIVE_SILENCE：用于实现错误抑制运算符。旧的错误报告级别备份到临时数据库中，稍后恢复。如果抛出异常，我们显然希望恢复它。这对应于END_SILENCE。<br>ZEND_LIVE_ROPE：用于绳索串连接，在这种情况下，临时数据是位于zend_string*堆栈上的固定大小的指针数组 。在这种情况下，所有已经被填充的字符串都必须被释放。大致对应于END_ROPE。<br>在这种情况下要考虑的一个棘手问题是，如果它们的产生或消费指令抛出，是否应该释放临时对象。考虑下面的简单代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T2 &#x3D; ADD T0, T1</span><br><span class="line">ASSIGN $v, T2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果ADD引发异常，T2临时应该自动释放还是ADD指令对此负责？同样，如果ASSIGN抛出，T2应该自动释放，还是ASSIGN必须自己处理？在后一种情况下，答案是明确的：即使抛出异常，指令总是负责释放其操作数。</p>
<p>结果操作数的情况比较棘手，因为这里的答案在PHP 7.1和7.2之间改变了：在PHP 7.1中，指令负责在发生异常时释放结果。在PHP7.2中，它被自动释放（并且该指令负责确保总是填充结果）。这种变化的动机是很多基本指令（如ADD）的实施方式。他们通常的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. read input operands</span><br><span class="line">2. perform operation, write it into result operand</span><br><span class="line">3. free input operands (if necessary)</span><br></pre></td></tr></table></figure>

<p>这是有问题的，因为PHP处于非常不幸的位置，不仅支持异常和析构函数，而且还支持抛出析构函数（这是编译器工程师惊恐地哭泣的地步）。因此，第3步可以抛出，在这一点上结果已经填充。为避免这种边缘情况下的内存泄漏，释放结果操作数的责任已从指令转移到异常处理机制。</p>
<p>一旦我们执行了这些清理操作，我们就可以继续执行catch块。如果没有catch（最后也没有），我们展开堆栈，也就是销毁当前的堆栈帧并在处理异常时给父帧一个<code>shot</code>。</p>
<p>因此，您可以充分理解整个异常处理业务的丑陋程度，我将介绍与抛出析构函数相关的另一个小技巧。这在实践中并不是很相关，但我们仍然需要处理它以确保正确性。考虑这个代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foreach (new Dtor as $value) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        echo &quot;Return&quot;;</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch (Exception $e) &#123;</span><br><span class="line">        echo &quot;Catch&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在想象这Dtor是一个带有析构函数的Traversable类。此代码将导致以下操作码序列，并且为了可读性而缩进循环主体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">L0:   V0 &#x3D; NEW &#39;Dtor&#39;, -&gt;L2</span><br><span class="line">L1:   DO_FCALL</span><br><span class="line">L2:   V2 &#x3D; FE_RESET_R V0, -&gt;L11</span><br><span class="line">L3:   FE_FETCH_R V2, $value</span><br><span class="line">L4:       ECHO &#39;Return&#39;</span><br><span class="line">L5:       FE_FREE (free on return) V2   # &lt;- return</span><br><span class="line">L6:       RETURN null                   # &lt;- return</span><br><span class="line">L7:       JMP -&gt;L10</span><br><span class="line">L8:       CATCH &#39;Exception&#39; $e</span><br><span class="line">L9:       ECHO &#39;Catch&#39;</span><br><span class="line">L10:  JMP -&gt;L3</span><br><span class="line">L11:  FE_FREE V2                        # &lt;- the duplicated instr</span><br></pre></td></tr></table></figure>

<p>重要的是，请注意“返回”被编译为循环变量的FE_FREE和RETURN。现在，如果FE_FREE抛出，会发生什么情况，因为Dtor抛出析构函数？通常，我们会说这个指令在try块内，所以我们应该调用catch。但是，在这一点上，循环变量已经被破坏！该catch抛弃异常，我们将尝试继续迭代已经死循环变量。</p>
<p>造成这个问题的原因是，当引发FE_FREE在try块内时，它是L11中FE_FREE的副本。从逻辑上讲，这是发生异常的地方。这就是为什么中断生成的FE_FREE被注释为FREE_ON_RETURN的原因。这指示异常处理机制将异常源移至原始释放指令。因此，上面的代码不会运行catch块，它会生成一个未捕获的异常。</p>
<h2 id="Finally处理（Finally-handling）"><a href="#Finally处理（Finally-handling）" class="headerlink" title="Finally处理（Finally handling）"></a>Finally处理（Finally handling）</h2><p>PHP与finally块相关的历史有点麻烦。PHP 5.5首先引入了最终块，或者更确切地说：最终块的一个非常错误的实现。PHP 5.6,7.0和7.1中的每一个都随着最终实现的重写而发布，每个都修复了大量错误，但未能完全实现完全正确的实现。</p>
<p>在编写本节时，我很惊讶地发现，从当前的实施和我目前的理解来看，最终处理实际上并不复杂。事实上，在许多方面，通过不同的迭代实现变得更简单，而不是更复杂。这表明对问题的理解不足可能会导致过于复杂和错误的实现（虽然公平地说，PHP 5实现的复杂性的一部分直接源于AST的缺乏）。</p>
<p>通常只要控件退出try块，正常（例如使用返回）或异常（通过抛出）就会运行Finally块。有几个有趣的边缘案例需要考虑，我将在进入实施之前快速阐述。请考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new Exception();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    return 42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么了？最后获胜并且函数返回42。请考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    return 24;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    return 42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally再次赢了，函数返回42。finally总是赢。</p>
<p>PHP禁止跳出finally块。例如以下是禁止的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foreach ($array as $value) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return 42;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码示例中的“continue”将生成一个编译错误。重要的是要明白，这个限制是纯粹<code>示例代码</code>(cosmetic)，并可以通过使用“众所周知的”catch控制委托模式轻松解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foreach ($array as $value) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return 42;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            throw new JumpException;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (JumpException $e) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在的唯一真正的限制是，它是不可能跳跃到 finally块，例如执行来自finally外部的goto跳转到finally内标签是被禁止的。</p>
<p>使用这个方式，我们可以初步的看看finally如何工作。该实现使用两个操作码FAST_CALL和FAST_RET。粗略地说，FAST_CALL用于跳到finally块，FAST_RET用于跳出它。让我们考虑最简单的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    echo &quot;try&quot;;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    echo &quot;finally&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;finished&quot;;</span><br></pre></td></tr></table></figure>

<p>此代码编译到以下操作码序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L0:   ECHO string(&quot;try&quot;)</span><br><span class="line">L1:   T0 &#x3D; FAST_CALL -&gt;L3</span><br><span class="line">L2:   JMP -&gt;L5</span><br><span class="line">L3:   ECHO string(&quot;finally&quot;)</span><br><span class="line">L4:   FAST_RET T0</span><br><span class="line">L5:   ECHO string(&quot;finished&quot;)</span><br><span class="line">L6:   RETURN int(1)</span><br></pre></td></tr></table></figure>

<p>FAST_CALL将自己的位置存储到T0中，并跳转到L3处的finally块中。当达到FAST_RET时，它跳回到T0中存储的位置（之后）。在这种情况下，L2围绕finally块跳转。这是没有特殊控制流程（返回或异常）发生的基本情况。现在我们来看一下这个特例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new Exception(&quot;try&quot;);</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    throw new Exception(&quot;catch&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    throw new Exception(&quot;finally&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理异常时，我们必须考虑抛出的异常相对于最接近的周围try / catch / finally块的位置：</p>
<ol>
<li>从try中抛出，并匹配catch：填充$e并跳入catch。</li>
<li>从try或catch中抛出，如果存在finally块：跳转到finally块，并且这次将异常备份到FAST_CALL临时变量（而不是在那里存储返回地址）。</li>
<li>从finally抛出：如果备份异常存在临时FAST_CALL中的，则将其作为先前抛出异常的异常链接。继续将异常冒泡到下一个try / catch / finally。</li>
<li>否则：继续将异常冒泡到下一个try / catch / finally。</li>
</ol>
<p>在这个例子中，我们将通过前三个步骤：首先尝试抛出，引发跳入catch。Catch也会抛出，触发到finally块的跳转，除非在FAST_CALL临时中备份。然后finally块也会抛出，这样，“finally”异常将会像之前的异常一样被设置为“catch”异常。</p>
<p>前面例子中的一个小变化是以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new Exception(&quot;try&quot;);</span><br><span class="line">    &#125; finally &#123;&#125;</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new Exception(&quot;catch&quot;);</span><br><span class="line">    &#125; finally &#123;&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw new Exception(&quot;finally&quot;);</span><br><span class="line">    &#125; finally &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的所有内部最终块都是异常输入，但通常保持不变（通过FAST_RET）。在这种情况下，先前描述的异常处理过程从父try / catch / finally块开始继续。这个父try / catch存储在FAST_RET操作码中（这里是“try-catch（0）”）。</p>
<p>这基本上涵盖finally和exceptions的关系。但finaly的返回呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    throw new Exception(&quot;try&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    return 42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作码序列的相关部分是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L4:   T0 &#x3D; FAST_CALL -&gt;L6</span><br><span class="line">L5:   JMP -&gt;L9</span><br><span class="line">L6:   DISCARD_EXCEPTION T0</span><br><span class="line">L7:   RETURN 42</span><br><span class="line">L8:   FAST_RET T0</span><br></pre></td></tr></table></figure>

<p>额外的DISCARD_EXCEPTION操作码负责放弃在try块中抛出的异常（记住：finally获胜的返回）。那么try的返回呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    $a &#x3D; 42;</span><br><span class="line">    return $a;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    ++$a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的例外返回值是42，而不是43.返回值由return$a行确定，任何进一步的修改$a都不重要。代码结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L0:   ASSIGN $a, 42</span><br><span class="line">L1:   T3 &#x3D; QM_ASSIGN $a</span><br><span class="line">L2:   T1 &#x3D; FAST_CALL -&gt;L6, T3</span><br><span class="line">L3:   RETURN T3</span><br><span class="line">L4:   T1 &#x3D; FAST_CALL -&gt;L6      # unreachable</span><br><span class="line">L5:   JMP -&gt;L8                 # unreachable</span><br><span class="line">L6:   PRE_INC $a</span><br><span class="line">L7:   FAST_RET T1</span><br><span class="line">L8:   RETURN null</span><br></pre></td></tr></table></figure>

<p>其中两个操作码无法访问，因为它们在返回后发生。这些将在优化期间被删除，但我在这里显示未优化的操作码。这里有两件有趣的事情：首先，<br>$a使用QM_ASSIGN（基本上是“复制到临时变量”指令）复制到T3中。这是防止后来修改$a 影响返回值的原因。其次，T3也传递给FAST_CALL，它将备份T1中的值。如果try块的返回值稍后被丢弃（例如，因为最后抛出或返回），则此机制将用于释放未使用的返回值。</p>
<p>所有这些单独的机制都很简单，但是在组成时需要谨慎。考虑下面的例子，其中又Dtor是一些带有抛出析构函数的Traversable类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    foreach (new Dtor as $v) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    echo &quot;finally&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码生成以下操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">L0:   V2 &#x3D; NEW (0 args) &quot;Dtor&quot;</span><br><span class="line">L1:   DO_FCALL</span><br><span class="line">L2:   V4 &#x3D; FE_RESET_R V2 -&gt;L16</span><br><span class="line">L3:   FE_FETCH_R V4 $v -&gt;L16</span><br><span class="line">L4:       T5 &#x3D; FAST_CALL -&gt;L10         # inner try</span><br><span class="line">L5:       FE_FREE (free on return) V4</span><br><span class="line">L6:       T1 &#x3D; FAST_CALL -&gt;L19</span><br><span class="line">L7:       RETURN 1</span><br><span class="line">L8:       T5 &#x3D; FAST_CALL -&gt;L10         # unreachable</span><br><span class="line">L9:       JMP -&gt;L15</span><br><span class="line">L10:      DISCARD_EXCEPTION T5         # inner finally</span><br><span class="line">L11:      FE_FREE (free on return) V4</span><br><span class="line">L12:      T1 &#x3D; FAST_CALL -&gt;L19</span><br><span class="line">L13:      RETURN 2</span><br><span class="line">L14:      FAST_RET T5 try-catch(0)</span><br><span class="line">L15:  JMP -&gt;L3</span><br><span class="line">L16:  FE_FREE V4</span><br><span class="line">L17:  T1 &#x3D; FAST_CALL -&gt;L19</span><br><span class="line">L18:  JMP -&gt;L21</span><br><span class="line">L19:  ECHO &quot;finally&quot;                   # outer finally</span><br><span class="line">L20:  FAST_RET T1</span><br></pre></td></tr></table></figure>

<p>第一次返回的序列（来自内部try）是FAST_CALL L10，FE_FREE V4，FAST_CALL L19，RETURN。这将首先调用内部finally块，然后释放foreach循环变量，然后调用外部finally块并返回。第二次返回的序列（最终来自内部）是DISCARD_EXCEPTION T5，FE_FREE V4，FAST_CALL L19。首先放弃内部try块的异常（或这里：返回值），然后释放foreach循环变量并最终调用外部finally块。请注意，在这两种情况下，这些指令的顺序是源代码中相关块的反向顺序。</p>
<h2 id="生成器（Generators）"><a href="#生成器（Generators）" class="headerlink" title="生成器（Generators）"></a>生成器（Generators）</h2><p>发生器功能可能会暂停和恢复，因此需要特殊的VM栈管理。这是一个简单的生成器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function gen($x) &#123;</span><br><span class="line">    foo(yield $x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生以下操作码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$x &#x3D; RECV 1</span><br><span class="line">GENERATOR_CREATE</span><br><span class="line">INIT_FCALL_BY_NAME (1 args) string(&quot;foo&quot;)</span><br><span class="line">V1 &#x3D; YIELD $x</span><br><span class="line">SEND_VAR_NO_REF_EX V1 1</span><br><span class="line">DO_FCALL_BY_NAME</span><br><span class="line">GENERATOR_RETURN null</span><br></pre></td></tr></table></figure>

<p>在到达GENERATOR_CREATE之前，这是在普通VM堆栈上作为普通函数执行的。GENERATOR_CREATE然后创建一个Generator对象，以及一个堆分配的execute_data结构（像往常一样包括变量和参数的槽），VM栈上的execute_data被复制到其中。</p>
<p>当生成器再次恢复时，执行器将使用堆分配的execute_data，但将继续使用主VM堆栈来推送调用帧。一个明显的问题是，如前面的例子所示，在调用过程中可能会中断发生器。这里YIELD是在调用foo()的调用帧已经被压入VM栈的时候执行的。</p>
<p>这种相对不常见的情况是通过在产生控制时将调用帧复制到发生器结构中并在发生器恢复时恢复它们来处理。</p>
<p>这个设计自PHP 7.1起使用。以前，每个发生器都有自己的4KiB虚拟机页面，当发生器恢复时它将被交换到执行器。这样可以避免复制调用帧，但会增加内存使用量。</p>
<h2 id="智能分支（Smart-branches）"><a href="#智能分支（Smart-branches）" class="headerlink" title="智能分支（Smart branches）"></a>智能分支（Smart branches）</h2><p>比较指令直接跟随条件跳转是很常见的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L0:   T2 &#x3D; IS_EQUAL $a, $b</span><br><span class="line">L1:   JMPZ T2 -&gt;L3</span><br><span class="line">L2:   ECHO &quot;equal&quot;</span><br></pre></td></tr></table></figure>

<p>由于这种模式非常普遍，所有比较操作码（如IS_EQUAL）都实现了智能分支机制：它们检查下一条指令是JMPZ还是JMPNZ指令，如果是，则自行执行相应的跳转操作。</p>
<p>智能分支机制只检查下一条指令是否是JMPZ/JMPNZ，但实际上并不检查其操作数是否实际上是比较的结果或其他。在比较和随后的跳跃不相关的情况下，这需要特别小心。例如，代码($a == $b) + ($d ? $e : $f)生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L0:   T5 &#x3D; IS_EQUAL $a, $b</span><br><span class="line">L1:   NOP</span><br><span class="line">L2:   JMPZ $d -&gt;L5</span><br><span class="line">L3:   T6 &#x3D; QM_ASSIGN $e</span><br><span class="line">L4:   JMP -&gt;L6</span><br><span class="line">L5:   T6 &#x3D; QM_ASSIGN $f</span><br><span class="line">L6:   T7 &#x3D; ADD T5 T6</span><br><span class="line">L7:   FREE T7</span><br></pre></td></tr></table></figure>

<p>请注意，在IS_EQUAL和JMPZ之间插入了NOP。如果这个NOP不存在，分支将最终使用IS_EQUAL结果，而不是JMPZ操作数。</p>
<h2 id="运行时缓存（Runtime-cache）"><a href="#运行时缓存（Runtime-cache）" class="headerlink" title="运行时缓存（Runtime cache）"></a>运行时缓存（Runtime cache）</h2><p>由于操作码数组在多个进程之间共享（无锁），因此它们是不可变的。但是，运行时值可以缓存在单独的“运行时缓存”中，该缓存基本上是一个指针数组。Literals可能有一个关联的运行时缓存条目（或多个），它存储在它们的u2插槽中。</p>
<p>运行时高速缓存条目有两种类型：第一种是普通高速缓存条目，例如INIT_FCALL使用的条目。INIT_FCALL查找一次被调用的函数（根据其名称）后，函数指针将被缓存在关联的运行时缓存槽中。</p>
<p>第二种类型是多态高速缓存条目，它们只是两个连续的高速缓存槽，其中第一个存储类条目，第二个存储实际数据。这些用于像FETCH_OBJ_R这样的操作，其中某个类的属性表中属性的偏移量被缓存。如果下一次访问发生在同一个类上（很有可能），则将使用缓存的值。否则，将执行更昂贵的查找操作，并将结果缓存到新的类条目中。</p>
<h2 id="VM中断（VM-interrupts）"><a href="#VM中断（VM-interrupts）" class="headerlink" title="VM中断（VM interrupts）"></a>VM中断（VM interrupts）</h2><p>在PHP 7.0之前，执行超时用于直接从信号处理程序通过longjump处理关闭序列。如你所想，这引起了各种不愉快的事情。由于PHP 7.0超时被延迟，直到控制权返回到虚拟机。如果它在特定的宽限期内没有返回，则该过程被中止。由于PHP 7.1 pcntl信号处理程序使用与执行超时相同的机制。</p>
<p>当一个信号挂起时，VM中断标志被设置，并且这个标志由虚拟机在某些点检查。检查不是在每条指令上执行，而是仅在跳转和调用时执行。因此，在返回到VM时不会立即处理中断，而是在线性控制流的当前部分结束时处理。</p>
<h2 id="特殊化（Specialization）"><a href="#特殊化（Specialization）" class="headerlink" title="特殊化（Specialization）"></a>特殊化（Specialization）</h2><p>如果查看VM定义文件，会发现操作码处理程序定义如下：</p>
<p><code>ZEND_VM_HANDLER(1, ZEND_ADD, CONST|TMPVAR|CV, CONST|TMPVAR|CV)</code></p>
<p>1在这里是操作码数，ZEND_ADD它的名字，而另外两个参数指定指令接受哪些类型的操作。所述生成的虚拟机代码（由生成zend_vm_gen.php然后）将包含为每个可能的操作数类型的组合的专门处理程序。生成有像ZEND_ADD_SPEC_CONST_CONST_HANDLER这样的名称。</p>
<p>专用处理程序是通过替换处理程序主体中的某些宏来生成的。比较容易看出的是OP1_TYPE和OP2_TYPE，但诸如GET_OP1_ZVAL_PTR（）和FREE_OP1（）等操作也是专用的。</p>
<p>ADD的处理程序指定它接受CONST|TMPVAR|CV操作数。这里的TMPVAR意味着操作码同时接受TMP和VAR，但要求这些不是单独专用的。请记住，对于大多数用途而言，TMP和VAR之间的唯一区别是后者可以包含引用。对于像ADD这样的操作码（无论如何，引用都在慢速路径（slow-path）上），单独进行特殊化并不值得。一些其他操作码确实可以区分TMP|VAR它们的操作数列表。</p>
<p>除了基于操作数类型的特殊化之外，处理程序还可以专门处理其他因素，例如是否使用其返回值。ASSIGN_DIM基于以下OP_DATA操作码的操作数类型进行特殊化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZEND_VM_HANDLER(147, ZEND_ASSIGN_DIM,</span><br><span class="line">    VAR|CV, CONST|TMPVAR|UNUSED|NEXT|CV, SPEC(OP_DATA&#x3D;CONST|TMP|VAR|CV))</span><br></pre></td></tr></table></figure>

<p>根据此签名，将生成2<em>4</em>4=32个不同的ASSIGN_DIM变体。第二个操作数的规范也包含一个条目NEXT。这与特殊化无关，而是指定了UNUSED操作数在此上下文中的含义：它表示这是一个附加操作（$arr[]）。另一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZEND_VM_HANDLER(23, ZEND_ASSIGN_ADD,</span><br><span class="line">    VAR|UNUSED|THIS|CV, CONST|TMPVAR|UNUSED|NEXT|CV, DIM_OBJ, SPEC(DIM_OBJ))</span><br></pre></td></tr></table></figure>

<p>在这里我们已经知道第一个操作数是UNUSED意味着一个访问$this。这是与对象有关的操作码的一般惯例，例如FETCH_OBJ_R UNUSED,’prop’对应于$this-&gt;prop。未使用的第二个操作数也意味着附加操作。这里的第三个参数指定的extended_value数的含义：它包含区分的标志$a += 1，$a[$b] += 1和$a-&gt;b += 1。最后，SPEC(DIM_OBJ)指示应该为每一个生成一个专门的处理程序。（在这种情况下，将生成的总处理程序数量并不重要，因为VM生成器知道某些组合是不可能的，例如UNUSED op1只与OBJ情况相关，等等）</p>
<p>最后，虚拟机生成器还支持更复杂的特殊化机制。在定义文件的末尾，你会发现一些这种形式的处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZEND_VM_TYPE_SPEC_HANDLER(</span><br><span class="line">    ZEND_ADD,</span><br><span class="line">    (res_info &#x3D;&#x3D; MAY_BE_LONG &amp;&amp; op1_info &#x3D;&#x3D; MAY_BE_LONG &amp;&amp; op2_info &#x3D;&#x3D; MAY_BE_LONG),</span><br><span class="line">    ZEND_ADD_LONG_NO_OVERFLOW,</span><br><span class="line">    CONST|TMPVARCV, CONST|TMPVARCV, SPEC(NO_CONST_CONST,COMMUTATIVE)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这些处理程序不仅基于VM操作数类型，还基于操作数在运行时可能采用的可能类型。确定可能的操作数类型的机制是opcache优化基础结构的一部分，这超出了本文的范围。但是，假设这些信息可用，应该清楚这是int + int -&gt; int一个附加的形式。此外，SPEC注释告诉specilizer，不应该生成两个const操作数的变体，并且操作是可交换的，所以如果我们已经有了CONST + TMPVARCV特殊化，我们也不需要生成TMPVARCV + CONST。</p>
<h2 id="快速路径-慢速路径分割（Fast-path-slow-path-split）"><a href="#快速路径-慢速路径分割（Fast-path-slow-path-split）" class="headerlink" title="快速路径/慢速路径分割（Fast-path / slow-path split）"></a>快速路径/慢速路径分割（Fast-path / slow-path split）</h2><p>许多操作码处理程序都是使用快速路径/慢速路径分割来实现的，其中首先处理几个常见情况，然后再回到通用实现。这是关于我们查看一些实际代码的时间了，所以我将在这里粘贴整个SL（左移）实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ZEND_VM_HANDLER(6, ZEND_SL, CONST|TMPVAR|CV, CONST|TMPVAR|CV)</span><br><span class="line">&#123;</span><br><span class="line">	USE_OPLINE</span><br><span class="line">	zend_free_op free_op1, free_op2;</span><br><span class="line">	zval *op1, *op2;</span><br><span class="line"></span><br><span class="line">	op1 &#x3D; GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R);</span><br><span class="line">	op2 &#x3D; GET_OP2_ZVAL_PTR_UNDEF(BP_VAR_R);</span><br><span class="line">	if (EXPECTED(Z_TYPE_INFO_P(op1) &#x3D;&#x3D; IS_LONG)</span><br><span class="line">			&amp;&amp; EXPECTED(Z_TYPE_INFO_P(op2) &#x3D;&#x3D; IS_LONG)</span><br><span class="line">			&amp;&amp; EXPECTED((zend_ulong)Z_LVAL_P(op2) &lt; SIZEOF_ZEND_LONG * 8)) &#123;</span><br><span class="line">		ZVAL_LONG(EX_VAR(opline-&gt;result.var), Z_LVAL_P(op1) &lt;&lt; Z_LVAL_P(op2));</span><br><span class="line">		ZEND_VM_NEXT_OPCODE();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SAVE_OPLINE();</span><br><span class="line">	if (OP1_TYPE &#x3D;&#x3D; IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_INFO_P(op1) &#x3D;&#x3D; IS_UNDEF)) &#123;</span><br><span class="line">		op1 &#x3D; GET_OP1_UNDEF_CV(op1, BP_VAR_R);</span><br><span class="line">	&#125;</span><br><span class="line">	if (OP2_TYPE &#x3D;&#x3D; IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_INFO_P(op2) &#x3D;&#x3D; IS_UNDEF)) &#123;</span><br><span class="line">		op2 &#x3D; GET_OP2_UNDEF_CV(op2, BP_VAR_R);</span><br><span class="line">	&#125;</span><br><span class="line">	shift_left_function(EX_VAR(opline-&gt;result.var), op1, op2);</span><br><span class="line">	FREE_OP1();</span><br><span class="line">	FREE_OP2();</span><br><span class="line">	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现通过GET_OPn_ZVAL_PTR_UNDEF以BP_VAR_R模式获取操作数开始。UNDEF这里的部分意味着在CV情况下不执行未定义变量的检查，而只是按照原样返回UNDEF值。一旦我们有操作数，我们检查两者是否都是整数，并且移位宽度在范围内，在这种情况下，结果可以直接计算出来，并且我们前进到下一个操作码。值得注意的是，这里的类型检查并不关心操作数是否为UNDEF，所以使用GET_OPN_ZVAL_PTR_UNDEF是合理的。</p>
<p>如果操作数不能满足快速路径，我们回到通用实现，该实现以SAVE_OPLINE（）开始。这是我们的信号“潜在的投掷操作”。在继续之前，处理未定义变量的情况。在这种情况下，GET_OPn_UNDEF_CV将发出未定义的变量通知并返回NULL值。</p>
<p>接下来，调用通用shift_left_function并将其结果写入EX_VAR(opline-&gt;result.var)。最后，输入操作数被释放（如果需要），并且我们前进到具有异常检查的下一个操作码（这意味着在前进之前重新装入操作数）。</p>
<p>因此，这里的快速路径保存了未定义变量的两个检查，对通用运算符函数的调用，释放操作数，以及保存和重新加载opline以进行异常处理。大部分性能敏感的操作码都以相似的方式排列。</p>
<h2 id="VM宏（VM-macros）"><a href="#VM宏（VM-macros）" class="headerlink" title="VM宏（VM macros）"></a>VM宏（VM macros）</h2><p>从前面的代码清单可以看出，虚拟机实现可以自由使用宏。其中一些是普通的C宏，而另一些则是在生成虚拟机时解决的。特别是，这包括许多用于获取和释放指令操作数的宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">OPn_TYPE</span><br><span class="line">OP_DATA_TYPE</span><br><span class="line"></span><br><span class="line">GET_OPn_ZVAL_PTR(BP_VAR_*)</span><br><span class="line">GET_OPn_ZVAL_PTR_DEREF(BP_VAR_*)</span><br><span class="line">GET_OPn_ZVAL_PTR_UNDEF(BP_VAR_*)</span><br><span class="line">GET_OPn_ZVAL_PTR_PTR(BP_VAR_*)</span><br><span class="line">GET_OPn_ZVAL_PTR_PTR_UNDEF(BP_VAR_*)</span><br><span class="line">GET_OPn_OBJ_ZVAL_PTR(BP_VAR_*)</span><br><span class="line">GET_OPn_OBJ_ZVAL_PTR_UNDEF(BP_VAR_*)</span><br><span class="line">GET_OPn_OBJ_ZVAL_PTR_DEREF(BP_VAR_*)</span><br><span class="line">GET_OPn_OBJ_ZVAL_PTR_PTR(BP_VAR_*)</span><br><span class="line">GET_OPn_OBJ_ZVAL_PTR_PTR_UNDEF(BP_VAR_*)</span><br><span class="line">GET_OP_DATA_ZVAL_PTR()</span><br><span class="line">GET_OP_DATA_ZVAL_PTR_DEREF()</span><br><span class="line"></span><br><span class="line">FREE_OPn()</span><br><span class="line">FREE_OPn_IF_VAR()</span><br><span class="line">FREE_OPn_VAR_PTR()</span><br><span class="line">FREE_UNFETCHED_OPn()</span><br><span class="line">FREE_OP_DATA()</span><br><span class="line">FREE_UNFETCHED_OP_DATA()</span><br></pre></td></tr></table></figure>


<p>可以看到，这里有不少变化。该BP_VAR_*参数指定的提取模式并支持相同的模式作为FETCH_ *（与FUNC_ARG除外）的说明。</p>
<p>GET_OPn_ZVAL_PTR()是基本的操作数获取。它会在未定义的CV上发出通知，并且不会取消操作数的取消引用。GET_OPn_ZVAL_PTR_UNDEF()正如我们已经知道的那样，它是一种不检查未定义的CV的变体。 GET_OPn_ZVAL_PTR_DEREF()包括zval的DEREF。这是专门的GET操作的一部分，因为解引用仅对于CV和VAR是必需的，但对于CONST和TMP不是必需的。因为这个宏需要区分TMP和VAR，它只能用于TMP|VAR专业化（但不能TMPVAR）。</p>
<p>这些GET_OPn_OBJ_ZVAL_PTR*()变体还处理UNUSED操作数的情况。如前所述，通过约定$this访问使用UNUSED操作数，所以GET_OPn_OBJ_ZVAL_PTR*()宏将返回EX(This)对UNUSED操作的引用。</p>
<p>最后，还有一些PTR_PTR变体。这里的命名是来自PHP5，其中这实际上使用了双向的zval指针。这些宏用于写操作，因此仅支持CV和VAR类型（其他任何返回NULL）。它们与正常的PTR提取不同，因为它们取消了VAR操作数。</p>
<p>这些FREE_OP*()宏然后用来释放取出的操作数。要进行操作，它们需要定义一个zend_free_op free_opN变量，GET操作将该 变量存储到该变量中以释放。基线FREE_OPn()操作将释放TMP和VAR，但不会释放CV和CONST。FREE_OPn_IF_VAR()完全按照它的说法：只有当它是VAR时才释放操作数。</p>
<p>该FREE_OP*_VAR_PTR()变体与PTR_PTR提取结合使用。它只会释放VAR操作数，并且只有在它们不是INDIRECTed的时候。</p>
<p>FREE_UNFETCHED_OP*()在使用GET获取操作数之前必须释放操作数的情况下使用这些变体。如果在操作数提取之前抛出异常，通常会发生这种情况。</p>
<p>除了这些特殊的宏之外，还有一些比较普通的宏。虚拟机定义了三个宏来控制操作码处理程序运行后发生的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_VM_CONTINUE()</span><br><span class="line">ZEND_VM_ENTER()</span><br><span class="line">ZEND_VM_LEAVE()</span><br><span class="line">ZEND_VM_RETURN()</span><br></pre></td></tr></table></figure>

<p>CONTINUE将继续正常执行操作码，而ENTER和LEAVE则用于进入/离开嵌套函数调用。这些操作的具体细节取决于VM编译的精确程度（例如，是否使用全局寄存器，如果是，使用哪一个）。从广义上讲，这些将在继续之前同步一些状态。RETURN用于实际退出主VM环路。</p>
<p>ZEND_VM_CONTINUE（）期望事先更新opline。当然，还有更多的宏相关：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>Continue?</th>
<th>Check exception?</th>
<th>Check interrupt?</th>
</tr>
</thead>
<tbody><tr>
<td>ZEND_VM_NEXT_OPCODE()</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION()</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>ZEND_VM_SET_NEXT_OPCODE(op)</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>ZEND_VM_SET_OPCODE(op)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>ZEND_VM_SET_RELATIVE_OPCODE(op, offset)</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>ZEND_VM_JMP(op)</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody></table>
<p>该表显示宏是否包含隐式ZEND_VM_CONTINUE（），是否会检查异常以及是否检查VM中断。</p>
<p>除此之外，还有SAVE_OPLINE()，LOAD_OPLINE()和HANDLE_EXCEPTION()。正如在异常处理一节中所提到的，SAVE_OPLINE（）在操作码处理程序中的第一个可能的抛出操作之前使用。如有必要，它将VM（可能位于全局寄存器中）使用的opline写回到执行数据中。LOAD_OPLINE（）是相反的操作，但现在它几乎没有用处，因为它已被有效地转入ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION（）和ZEND_VM_JMP（）。</p>
<p>HANDLE_EXCEPTION（）用于在已经知道引发异常后从操作码处理程序返回。它执行LOAD_OPLINE和CONTINUE的组合，这将有效地分派到HANDLE_EXCEPTION操作码。</p>
<p>当然，还有更多的宏，但以上应该已经包含了最重要的部分。</p>
<p>译自：<a href="https://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html#writes-and-memory-safety" target="_blank" rel="noopener">PHP 7 Virtual Machine</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Young</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>